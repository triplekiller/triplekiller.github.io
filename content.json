{"meta":{"title":"Ethan's Blog","subtitle":"","description":"Keep thinking and keep moving","author":"Ethan X","url":"http://bit2tib.com"},"pages":[{"title":"About Me","date":"2017-04-10T14:50:38.000Z","updated":"2017-07-23T08:47:20.583Z","comments":false,"path":"about/index.html","permalink":"http://bit2tib.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-04-04T06:36:22.000Z","updated":"2017-07-23T08:47:20.583Z","comments":false,"path":"categories/index.html","permalink":"http://bit2tib.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-04T06:34:57.000Z","updated":"2017-07-23T08:47:20.583Z","comments":false,"path":"tags/index.html","permalink":"http://bit2tib.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux Zombie","slug":"linux-zombie","date":"2017-04-16T14:34:59.000Z","updated":"2017-07-23T08:47:20.583Z","comments":true,"path":"2017/04/16/linux-zombie/","link":"","permalink":"http://bit2tib.com/2017/04/16/linux-zombie/","excerpt":"","text":"僵尸进程：defunt/zombie 一个已经终止但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息，释放它 仍占用的资源）的进程 子进程死后会发送SIGCHLD信号给父进程，父进程收到此信号后，执行waitpid()函数为子 进程收尸 在fork/execve过程中，假设子进程结束时父进程仍存在，而父进程fork之前既没安装 SIGCHLD信号处理函数调用waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成 为僵尸进程，无法正常结束，此时即使是root身份kill -9也不能杀死僵尸进程。补救办法 是杀死僵尸进程的父进程(僵尸进程的父进程必然存在)，僵尸进程成为”孤儿进程”，过继给 1号进程init，init始终会负责清理僵尸进程 系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进 程，并不能将其完全销毁。一个进程在调用exit命令结束自己的生命的时候，其实它并没有 真正的被销毁，而是留下一个称为僵尸进程(Zombie)的数据结构 僵尸进程已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进 程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集 避免僵尸进程 调用signal函数忽略SIGCHLD软中断: signal(SIGCHLD, SIG_IGN) 调用wait/waitpid接管SIGCHLD信号，等待子进程返回while(pid != waitpid(pid, NULL, WNOHANG)) fork两次，子进程先退出，孙子进程就被init接管了，实际上与最初的父进程脱离了关系 ，就不会僵死了 僵尸进程危害 Linux有最大进程数量限制，可用”ulimit -u”查看最大用户进程数，默认为32768(cat /proc/sys/kernel/pid_max) 产生过多的zombie进程会导致新进程无法生存","categories":[{"name":"Tech","slug":"Tech","permalink":"http://bit2tib.com/categories/Tech/"}],"tags":[{"name":"process","slug":"process","permalink":"http://bit2tib.com/tags/process/"}]}]}